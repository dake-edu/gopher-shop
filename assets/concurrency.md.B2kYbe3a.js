import{_ as i,o as a,c as e,ae as n}from"./chunks/framework.CfVLvsAT.js";const d=JSON.parse('{"title":"Chapter 22: Concurrency","description":"","frontmatter":{},"headers":[],"relativePath":"concurrency.md","filePath":"concurrency.md"}'),t={name:"concurrency.md"};function h(l,s,o,r,p,k){return a(),e("div",null,[...s[0]||(s[0]=[n(`<h1 id="chapter-22-concurrency" tabindex="-1">Chapter 22: Concurrency <a class="header-anchor" href="#chapter-22-concurrency" aria-label="Permalink to &quot;Chapter 22: Concurrency&quot;">â€‹</a></h1><blockquote><p><strong>&quot;Concurrency is not Parallelism.&quot;</strong> - Rob Pike</p></blockquote><p>Up until now, your code did one thing at a time. It was a single worker. But real shops start doing many things at once. One clerk checks credentials, another fetches the product, a third calculates shipping.</p><p>In Go, we don&#39;t have &quot;Threads&quot; (which are heavy, like 2MB each). We have <strong>Goroutines</strong> (which are light, like 2KB each). You can launch millions of them.</p><h2 id="_22-1-the-worker-goroutine" tabindex="-1">22.1 The Worker (Goroutine) <a class="header-anchor" href="#_22-1-the-worker-goroutine" aria-label="Permalink to &quot;22.1 The Worker (Goroutine)&quot;">â€‹</a></h2><p>To start a task in the background, just put <code>go</code> in front of it.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    go</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sendEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Welcome!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Leaves immediately!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Done&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This spawns a new &quot;Elf&quot; to do the work. The <code>main</code> function doesn&#39;t wait for him. It finishes and exits. <strong>Warning</strong>: If <code>main</code> dies, all Elves die instantly, even if they aren&#39;t finished.</p><h2 id="_22-2-the-conveyor-belt-channels" tabindex="-1">22.2 The Conveyor Belt (Channels) <a class="header-anchor" href="#_22-2-the-conveyor-belt-channels" aria-label="Permalink to &quot;22.2 The Conveyor Belt (Channels)&quot;">â€‹</a></h2><p>If Elves work silently, how do they talk? They use <strong>Channels</strong>. Think of a Channel as a pipe. One Elf puts data in one end, another takes it out the other.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">chan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">go</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Job Done!&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Send</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">msg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ch </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Receive (Waits until data arrives)</span></span></code></pre></div><h2 id="_22-3-the-worker-pool" tabindex="-1">22.3 The Worker Pool <a class="header-anchor" href="#_22-3-the-worker-pool" aria-label="Permalink to &quot;22.3 The Worker Pool&quot;">â€‹</a></h2><p>Imagine you have 1,000 images to process. If you launch 1,000 goroutines, you might crash the server. Instead, you hire a fixed team (e.g., 3 Workers) and give them a shared pile of work.</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Tasks[Job Queue] --&gt;|Channel| W1[Worker 1]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Tasks --&gt;|Channel| W2[Worker 2]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Tasks --&gt;|Channel| W3[Worker 3]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    W1 --&gt;|Result| Done</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    W2 --&gt;|Result| Done</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    W3 --&gt;|Result| Done</span></span></code></pre></div><h2 id="_22-4-the-toilet-lock-mutex" tabindex="-1">22.4 The Toilet Lock (Mutex) <a class="header-anchor" href="#_22-4-the-toilet-lock-mutex" aria-label="Permalink to &quot;22.4 The Toilet Lock (Mutex)&quot;">â€‹</a></h2><p>Sometimes, two workers need to use the same resource (like a map or a counter). If they touch it at the same time, data gets corrupted (Race Condition). We need a lock. In Go, it&#39;s <code>sync.Mutex</code>.</p><p>Think of it like a <strong>Toilet Door</strong>.</p><ol><li><strong>Lock()</strong>: You enter and lock the door. Everyone else waits outside.</li><li><strong>Unlock()</strong>: You leave. The next person can enter.</li></ol><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mu.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Safe zone</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mu.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><details class="details custom-block"><summary>ðŸŽ“ Knowledge Check: What is a Race Condition?</summary><p><strong>Answer</strong>: A bug where two threads/goroutines try to write to the same memory at the same time. The result is unpredictable garbage. Fixing it requires synchronization (Mutex or Channels).</p></details>`,20)])])}const g=i(t,[["render",h]]);export{d as __pageData,g as default};
