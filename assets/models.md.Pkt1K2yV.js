import{_ as e,o as s,c as a,ae as o}from"./chunks/framework.CfVLvsAT.js";const g=JSON.parse('{"title":"8. The Blueprint (Data Modeling)","description":"","frontmatter":{},"headers":[],"relativePath":"models.md","filePath":"models.md"}'),i={name:"models.md"};function n(l,t,d,r,c,h){return s(),a("div",null,[...t[0]||(t[0]=[o('<h1 id="_8-the-blueprint-data-modeling" tabindex="-1">8. The Blueprint (Data Modeling) <a class="header-anchor" href="#_8-the-blueprint-data-modeling" aria-label="Permalink to &quot;8. The Blueprint (Data Modeling)&quot;">â€‹</a></h1><h2 id="_8-1-the-struct-the-container" tabindex="-1">8.1 The Struct (The Container) <a class="header-anchor" href="#_8-1-the-struct-the-container" aria-label="Permalink to &quot;8.1 The Struct (The Container)&quot;">â€‹</a></h2><p>In Java or Python, you might use a <code>Class</code>. In Go, we use a <code>struct</code>. A struct is purely data. It has no hidden machinery.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Book</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ID      </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  `json:&quot;id&quot;`</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Title   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  `json:&quot;title&quot;`</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Price   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float64</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `json:&quot;price&quot;`</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="anatomy-of-the-code" tabindex="-1">Anatomy of the Code <a class="header-anchor" href="#anatomy-of-the-code" aria-label="Permalink to &quot;Anatomy of the Code&quot;">â€‹</a></h3><ol><li><strong><code>type</code></strong>: New Type Definition. We are inventing a custom data type named <code>Book</code>.</li><li><strong><code>struct</code></strong>: The kind of type. It means &quot;Structure&quot;, a composite of fields.</li><li><strong><code>ID string</code></strong>: Field Name (<code>ID</code>) and Data Type (<code>string</code>). <ul><li><em>Note</em>: Capitalized <code>ID</code> means <strong>Public</strong> (Exported). If we wrote <code>id</code> (lowercase), other packages could not see it.</li></ul></li><li><strong><code>`json:&quot;id&quot;`</code></strong>: The Tag. (See 8.2).</li></ol><h3 id="comparison-struct-vs-class" tabindex="-1">Comparison: Struct vs Class <a class="header-anchor" href="#comparison-struct-vs-class" aria-label="Permalink to &quot;Comparison: Struct vs Class&quot;">â€‹</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">Feature</th><th style="text-align:left;">Java Class</th><th style="text-align:left;">Python DataClass</th><th style="text-align:left;">Go Struct</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Inheritance</strong></td><td style="text-align:left;">Yes (<code>extends</code>)</td><td style="text-align:left;">Yes</td><td style="text-align:left;"><strong>No (Composition)</strong></td></tr><tr><td style="text-align:left;"><strong>Methods</strong></td><td style="text-align:left;">Inside Class</td><td style="text-align:left;">Inside Class</td><td style="text-align:left;"><strong>Attached Separately</strong></td></tr><tr><td style="text-align:left;"><strong>Visibility</strong></td><td style="text-align:left;"><code>public</code>/<code>private</code></td><td style="text-align:left;"><code>_</code> convention</td><td style="text-align:left;"><strong>Capitalized (Public)</strong></td></tr></tbody></table><h2 id="_8-2-tags-reflecting-instructions" tabindex="-1">8.2 Tags (Reflecting Instructions) <a class="header-anchor" href="#_8-2-tags-reflecting-instructions" aria-label="Permalink to &quot;8.2 Tags (Reflecting Instructions)&quot;">â€‹</a></h2><p>What is that stuff in backticks? <code>`json:&quot;id&quot;`</code>?</p><p>This is <strong>Metadata</strong>. Imagine you are handing this struct to a specialized robot called the &quot;JSON Encoder&quot;. The robot reads the tag:</p><blockquote><p><em>&quot;Oh, the human called this field <code>ID</code> in Go, but when I turn it into text for the browser, I should label it <code>id</code> (lowercase).&quot;</em></p></blockquote><p>If you omit tags, the JSON output will look like <code>{&quot;ID&quot;: &quot;123&quot;}</code>, which is not standard for web APIs (which prefer <code>snake_case</code> or <code>camelCase</code>).</p><details class="details custom-block"><summary>ðŸŽ“ Knowledge Check: What is the difference between <code>ID</code> and <code>id</code> in a struct field?</summary><p><strong>Answer</strong>:</p><ul><li><strong><code>ID</code> (Capitalized)</strong>: Public (Exported). Visible to other packages and JSON encoders.</li><li><strong><code>id</code> (Lowercase)</strong>: Private (Unexported). Hidden from everyone outside this package.</li></ul></details>',14)])])}const u=e(i,[["render",n]]);export{g as __pageData,u as default};
