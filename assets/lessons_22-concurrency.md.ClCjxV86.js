import{_ as n,C as o,o as e,c as h,a0 as a,b as l,w as i,a as r,E as k,a1 as p}from"./chunks/framework.6sfUeJuU.js";const _=JSON.parse('{"title":"Chapter 22: Concurrency","description":"","frontmatter":{},"headers":[],"relativePath":"lessons/22-concurrency.md","filePath":"lessons/22-concurrency.md"}'),d={name:"lessons/22-concurrency.md"};function c(g,s,u,E,y,m){const t=o("Mermaid");return e(),h("div",null,[s[1]||(s[1]=a(`<h1 id="chapter-22-concurrency" tabindex="-1">Chapter 22: Concurrency <a class="header-anchor" href="#chapter-22-concurrency" aria-label="Permalink to &quot;Chapter 22: Concurrency&quot;">â€‹</a></h1><blockquote><p><strong>&quot;Concurrency is not Parallelism.&quot;</strong> - Rob Pike</p></blockquote><p>Up until now, your code did one thing at a time. It was a single worker. But real shops start doing many things at once. One clerk checks credentials, another fetches the product, a third calculates shipping.</p><p>In Go, we don&#39;t have &quot;Threads&quot; (which are heavy, like 2MB each). We have <strong>Goroutines</strong> (which are light, like 2KB each). You can launch millions of them.</p><h2 id="_22-1-the-worker-goroutine" tabindex="-1">22.1 The Worker (Goroutine) <a class="header-anchor" href="#_22-1-the-worker-goroutine" aria-label="Permalink to &quot;22.1 The Worker (Goroutine)&quot;">â€‹</a></h2><p>To start a task in the background, just put <code>go</code> in front of it.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    go</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sendEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Welcome!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Leaves immediately!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Done&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This spawns a new &quot;Elf&quot; to do the work. The <code>main</code> function doesn&#39;t wait for him. It finishes and exits. <strong>Warning</strong>: If <code>main</code> dies, all Elves die instantly, even if they aren&#39;t finished.</p><h2 id="_22-2-the-conveyor-belt-channels" tabindex="-1">22.2 The Conveyor Belt (Channels) <a class="header-anchor" href="#_22-2-the-conveyor-belt-channels" aria-label="Permalink to &quot;22.2 The Conveyor Belt (Channels)&quot;">â€‹</a></h2><p>If Elves work silently, how do they talk? They use <strong>Channels</strong>. Think of a Channel as a pipe. One Elf puts data in one end, another takes it out the other.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">chan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">go</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Job Done!&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Send</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">msg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ch </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Receive (Waits until data arrives)</span></span></code></pre></div><h2 id="_22-3-the-worker-pool" tabindex="-1">22.3 The Worker Pool <a class="header-anchor" href="#_22-3-the-worker-pool" aria-label="Permalink to &quot;22.3 The Worker Pool&quot;">â€‹</a></h2><p>Imagine you have 1,000 images to process. If you launch 1,000 goroutines, you might crash the server. Instead, you hire a fixed team (e.g., 3 Workers) and give them a shared pile of work.</p>`,13)),(e(),l(p,null,{default:i(()=>[k(t,{id:"mermaid-37",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20Tasks%5BJob%20Queue%5D%20--%3E%7CChannel%7C%20W1%5BWorker%201%5D%0A%20%20%20%20Tasks%20--%3E%7CChannel%7C%20W2%5BWorker%202%5D%0A%20%20%20%20Tasks%20--%3E%7CChannel%7C%20W3%5BWorker%203%5D%0A%20%20%20%20W1%20--%3E%7CResult%7C%20Done%0A%20%20%20%20W2%20--%3E%7CResult%7C%20Done%0A%20%20%20%20W3%20--%3E%7CResult%7C%20Done%0A"})]),fallback:i(()=>[...s[0]||(s[0]=[r(" Loading... ",-1)])]),_:1})),s[2]||(s[2]=a(`<h2 id="_22-4-the-toilet-lock-mutex" tabindex="-1">22.4 The Toilet Lock (Mutex) <a class="header-anchor" href="#_22-4-the-toilet-lock-mutex" aria-label="Permalink to &quot;22.4 The Toilet Lock (Mutex)&quot;">â€‹</a></h2><p>Sometimes, two workers need to use the same resource (like a map or a counter). If they touch it at the same time, data gets corrupted (Race Condition). We need a lock. In Go, it&#39;s <code>sync.Mutex</code>.</p><p>Think of it like a <strong>Toilet Door</strong>.</p><ol><li><strong>Lock()</strong>: You enter and lock the door. Everyone else waits outside.</li><li><strong>Unlock()</strong>: You leave. The next person can enter.</li></ol><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mu.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Safe zone</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mu.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><details class="details custom-block"><summary>ðŸŽ“ Knowledge Check: What is a Race Condition?</summary><p><strong>Answer</strong>: A bug where two threads/goroutines try to write to the same memory at the same time. The result is unpredictable garbage. Fixing it requires synchronization (Mutex or Channels).</p></details>`,6))])}const b=n(d,[["render",c]]);export{_ as __pageData,b as default};
